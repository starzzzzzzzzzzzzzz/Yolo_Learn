"""
YOLOv2 vs YOLOv8 对比演示
直观展示两个版本的差异
"""

import numpy as np
from typing import Dict, List


# ================================
# 1. 架构对比
# ================================

def architecture_comparison():
    """
    对比 YOLOv2 和 YOLOv8 的架构
    """
    print("=" * 80)
    print("架构对比：YOLOv2 vs YOLOv8")
    print("=" * 80)
    
    comparison = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                          组件对比                                            │
├──────────────────┬────────────────────────┬────────────────────────────────┤
│    组件          │      YOLOv2            │         YOLOv8                 │
├──────────────────┼────────────────────────┼────────────────────────────────┤
│ 骨干网络         │ Darknet-19             │ CSPDarknet + C2f               │
│                  │ • 19 层卷积            │ • 更深的网络                   │
│                  │ • 5 个 MaxPool         │ • C2f: 丰富梯度流              │
│                  │ • 1×1 和 3×3 卷积      │ • SPPF: 空间金字塔池化         │
├──────────────────┼────────────────────────┼────────────────────────────────┤
│ Neck             │ Passthrough 层         │ PAN (Path Aggregation)         │
│ (特征融合)       │ • 26×26 → 13×13        │ • 双向特征金字塔               │
│                  │ • 简单拼接             │ • 自顶向下 + 自底向上          │
│                  │                        │ • 3 个尺度充分融合             │
├──────────────────┼────────────────────────┼────────────────────────────────┤
│ 检测头           │ 耦合头                 │ 解耦头                         │
│                  │ • 单一输出分支         │ • 分类分支 独立                │
│                  │ • 位置+分类一起预测    │ • 回归分支 独立                │
│                  │                        │ • 任务专用，性能更好           │
├──────────────────┼────────────────────────┼────────────────────────────────┤
│ 输出尺度         │ 单尺度                 │ 多尺度                         │
│                  │ • 13×13 (仅一个)       │ • 80×80 (小目标)               │
│                  │                        │ • 40×40 (中目标)               │
│                  │                        │ • 20×20 (大目标)               │
├──────────────────┼────────────────────────┼────────────────────────────────┤
│ Anchor 策略      │ 基于 Anchor            │ Anchor-Free                    │
│                  │ • 5 个预定义 anchors   │ • 直接预测中心点               │
│                  │ • K-means 聚类         │ • 无需超参数                   │
│                  │ • 相对偏移预测         │ • 更好泛化                     │
└──────────────────┴────────────────────────┴────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────────┐
│                          网络深度对比                                        │
└─────────────────────────────────────────────────────────────────────────────┘

YOLOv2 (Darknet-19):
┌───────────┐
│  输入 3   │ 416×416
└─────┬─────┘
      │ Conv 3×3, /2
┌─────▼─────┐
│   32      │ 208×208
└─────┬─────┘
      │ MaxPool
┌─────▼─────┐
│   32      │ 104×104
└─────┬─────┘
      │ Conv + MaxPool
┌─────▼─────┐
│   128     │ 52×52
└─────┬─────┘
      │ Conv + MaxPool
┌─────▼─────┐
│   256     │ 26×26 ────┐ (Passthrough)
└─────┬─────┘           │
      │ Conv + MaxPool  │
┌─────▼─────┐           │
│   512     │ 13×13     │
└─────┬─────┘           │
      │ MaxPool         │
┌─────▼─────┐           │
│   1024    │ 13×13     │
└─────┬─────┘           │
      │ Conv            │
┌─────▼─────────────────▼─┐
│   输出: 13×13×125       │ (5 anchors × 25)
└─────────────────────────┘

YOLOv8 (CSPDarknet + PAN):
┌───────────┐
│  输入 3   │ 640×640
└─────┬─────┘
      │ Conv
┌─────▼─────┐
│   64      │ 320×320
└─────┬─────┘
      │ Conv + C2f
┌─────▼─────┐
│   128     │ 160×160
└─────┬─────┘
      │ Conv + C2f
┌─────▼─────┐
│   256     │ 80×80  ────────┐ P3
└─────┬─────┘                │
      │ Conv + C2f           │
┌─────▼─────┐                │
│   512     │ 40×40  ────┐   │ P4
└─────┬─────┘            │   │
      │ Conv + C2f + SPPF│   │
┌─────▼─────┐            │   │
│   1024    │ 20×20  ─┐  │   │ P5
└───────────┘         │  │   │
                      │  │   │
┌─────────────────────┴──┴───┴─┐
│      PAN (特征融合)           │
│   ┌──────────────────────┐   │
│   │ Top-Down Pathway     │   │
│   │ P5 → P4 → P3         │   │
│   └──────────────────────┘   │
│   ┌──────────────────────┐   │
│   │ Bottom-Up Pathway    │   │
│   │ P3 → P4 → P5         │   │
│   └──────────────────────┘   │
└──────┬──────┬──────┬─────────┘
       │      │      │
       │ 80×80│ 40×40│ 20×20
       │      │      │
   ┌───▼──┐┌──▼──┐┌──▼───┐
   │ Head ││Head ││ Head │ (解耦头)
   └──────┘└─────┘└──────┘
    """
    
    print(comparison)


# ================================
# 2. 预测流程对比
# ================================

def prediction_flow_comparison():
    """
    对比预测流程
    """
    print("\n" + "=" * 80)
    print("预测流程对比")
    print("=" * 80)
    
    flow = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                        YOLOv2 预测流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

输入图像 (416×416×3)
    │
    ▼
┌─────────────────────┐
│   Darknet-19        │
│   特征提取          │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│   Passthrough       │
│   融合 26×26 特征   │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐
│   检测层            │
│   13×13×125         │
│   (5×25)            │
└──────┬──────────────┘
       │
       ▼
对于每个 grid cell (13×13 = 169 个):
    对于每个 anchor (5 个):
        ┌──────────────────────────────┐
        │ 预测 5+C 个值:               │
        │ • tx, ty (中心偏移)          │
        │ • tw, th (宽高缩放)          │
        │ • confidence (置信度)        │
        │ • class_probs (C 个类别概率) │
        └────────┬─────────────────────┘
                 │
                 ▼
        ┌──────────────────────────────┐
        │ 解码边界框:                   │
        │ bx = sigmoid(tx) + cx        │
        │ by = sigmoid(ty) + cy        │
        │ bw = pw × exp(tw)            │
        │ bh = ph × exp(th)            │
        │ score = σ(conf) × σ(cls)     │
        └────────┬─────────────────────┘
                 │
                 ▼
总预测框数: 13×13×5 = 845 个
    │
    ▼
┌─────────────────────┐
│   NMS (非极大抑制)  │
│   IoU threshold     │
└──────┬──────────────┘
       │
       ▼
最终检测结果


┌─────────────────────────────────────────────────────────────────────────────┐
│                        YOLOv8 预测流程                                       │
└─────────────────────────────────────────────────────────────────────────────┘

输入图像 (640×640×3)
    │
    ▼
┌─────────────────────┐
│   CSPDarknet        │
│   特征提取          │
└──────┬──────────────┘
       │
       ├─ P3: 80×80×256
       ├─ P4: 40×40×512
       └─ P5: 20×20×1024
       │
       ▼
┌─────────────────────┐
│   PAN Neck          │
│   特征融合          │
└──────┬──────────────┘
       │
       ├─ N3: 80×80 (小目标)
       ├─ N4: 40×40 (中目标)
       └─ N5: 20×20 (大目标)
       │
       ▼
对于每个尺度:
    对于每个 grid cell:
        ┌──────────────────────────────┐
        │ 解耦头预测:                   │
        │                              │
        │ 回归分支:                    │
        │ • DFL (分布式聚焦损失)       │
        │   - 4 edges × 16 bins       │
        │   - 软化的边界框预测         │
        │                              │
        │ 分类分支:                    │
        │ • C 个类别的 logits          │
        └────────┬─────────────────────┘
                 │
                 ▼
        ┌──────────────────────────────┐
        │ 后处理:                       │
        │ • DFL → 边界框坐标           │
        │ • Sigmoid → 类别概率         │
        │ • 直接输出 (cx,cy,w,h)       │
        │   (无需 anchor!)             │
        └────────┬─────────────────────┘
                 │
                 ▼
总预测框数: (80×80 + 40×40 + 20×20) = 8400 个
    │
    ▼
┌─────────────────────┐
│   NMS (非极大抑制)  │
│   IoU threshold     │
└──────┬──────────────┘
       │
       ▼
最终检测结果


┌─────────────────────────────────────────────────────────────────────────────┐
│                        关键差异总结                                          │
└─────────────────────────────────────────────────────────────────────────────┘

1. 输出尺度:
   YOLOv2: 单尺度 (13×13)     → 845 个预测框
   YOLOv8: 多尺度 (3 个)       → 8400 个预测框

2. Anchor 使用:
   YOLOv2: 5 个预定义 anchors  → 需要 K-means
   YOLOv8: 无 anchors          → 直接预测

3. 检测头:
   YOLOv2: 耦合头 (位置+类别)  → 单一分支
   YOLOv8: 解耦头              → 分类、回归独立

4. 边界框编码:
   YOLOv2: 相对 anchor 偏移    → (tx,ty,tw,th)
   YOLOv8: 直接中心点坐标      → (cx,cy,w,h) + DFL

5. 预测精度:
   YOLOv2: 较粗糙              → exp(tw) 不稳定
   YOLOv8: 更精确              → DFL 软化预测

6. 小目标检测:
   YOLOv2: 有限                → 仅 13×13 (粗糙)
   YOLOv8: 显著提升            → 80×80 高分辨率
    """
    
    print(flow)


# ================================
# 3. 损失函数对比
# ================================

def loss_function_comparison():
    """
    对比损失函数
    """
    print("\n" + "=" * 80)
    print("损失函数对比")
    print("=" * 80)
    
    loss_comp = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                        YOLOv2 损失函数                                       │
└─────────────────────────────────────────────────────────────────────────────┘

总损失 = λ_coord × L_coord + λ_conf × L_conf + λ_cls × L_cls

1. 坐标损失 (L_coord):
   L_coord = Σ[i=0 to S²] Σ[j=0 to B] 𝟙ᵢⱼᵒᵇʲ [(xᵢ - x̂ᵢ)² + (yᵢ - ŷᵢ)²
                                           + (√wᵢ - √ŵᵢ)² + (√hᵢ - √ĥᵢ)²]
   
   • 使用 MSE (均方误差)
   • 对宽高取平方根 (减小大框的惩罚)
   • λ_coord = 5 (增加坐标损失权重)

2. 置信度损失 (L_conf):
   L_conf = Σ[i=0 to S²] Σ[j=0 to B] [𝟙ᵢⱼᵒᵇʲ (Cᵢⱼ - Ĉᵢⱼ)²
                                    + λ_noobj × 𝟙ᵢⱼⁿᵒᵒᵇʲ (Cᵢⱼ - Ĉᵢⱼ)²]
   
   • 使用 MSE
   • λ_noobj = 0.5 (减小负样本权重)
   • 区分有目标和无目标的 grid cell

3. 分类损失 (L_cls):
   L_cls = Σ[i=0 to S²] 𝟙ᵢᵒᵇʲ Σ[c∈classes] (pᵢ(c) - p̂ᵢ(c))²
   
   • 使用 MSE
   • 只对包含目标的 grid cell 计算


┌─────────────────────────────────────────────────────────────────────────────┐
│                        YOLOv8 损失函数                                       │
└─────────────────────────────────────────────────────────────────────────────┘

总损失 = L_cls + L_box + L_dfl

1. 分类损失 (L_cls) - BCE Loss:
   L_cls = -Σ [yᵢ log(pᵢ) + (1-yᵢ) log(1-pᵢ)]
   
   • 二元交叉熵 (每个类别独立)
   • 支持多标签分类
   • 更稳定的梯度

2. 边界框损失 (L_box) - CIoU Loss:
   L_box = 1 - IoU + ρ²(b, b^gt)/c² + αv
   
   其中:
   • IoU: 交并比
   • ρ: 中心点距离
   • c: 对角线长度
   • v: 宽高比一致性
   • α: 权重因子
   
   优势:
   • 考虑重叠度 (IoU)
   • 考虑中心点距离
   • 考虑宽高比
   • 即使不重叠也有梯度

3. 分布式聚焦损失 (L_dfl):
   L_dfl = -Σ ((yᵢ₊₁ - y) log(Sᵢ) + (y - yᵢ) log(Sᵢ₊₁))
   
   • 将回归转换为分类问题
   • 预测目标位置的概率分布
   • 提供更精确的定位
   
   示例 (预测一条边):
   距离 = 5.3
   → bin 5: 权重 0.7
   → bin 6: 权重 0.3
   
   最终预测 = Σ(bin_value × probability)


┌─────────────────────────────────────────────────────────────────────────────┐
│                        对比总结                                              │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────────┬─────────────────────┬──────────────────────────────┐
│  损失类型    │      YOLOv2         │         YOLOv8               │
├──────────────┼─────────────────────┼──────────────────────────────┤
│ 分类损失     │ MSE                 │ BCE (Binary Cross Entropy)   │
│              │ • 不适合分类        │ • 标准分类损失               │
│              │ • 梯度不稳定        │ • 稳定的梯度                 │
├──────────────┼─────────────────────┼──────────────────────────────┤
│ 边界框损失   │ MSE (L2)            │ CIoU (Complete IoU)          │
│              │ • 对大小框不公平    │ • 考虑多个因素               │
│              │ • 需要 √ 调整       │ • 更好的收敛                 │
├──────────────┼─────────────────────┼──────────────────────────────┤
│ 置信度损失   │ MSE                 │ 无 (anchor-free)             │
│              │ • 正负样本平衡      │ • 不需要置信度               │
├──────────────┼─────────────────────┼──────────────────────────────┤
│ 特殊损失     │ 无                  │ DFL (Distribution Focal)     │
│              │                     │ • 软化的位置预测             │
│              │                     │ • 更精确的定位               │
└──────────────┴─────────────────────┴──────────────────────────────┘

性能影响:
• YOLOv2: 简单但次优的损失函数
• YOLOv8: 现代、优化的损失函数 → 更高精度
    """
    
    print(loss_comp)


# ================================
# 4. 性能对比
# ================================

def performance_comparison():
    """
    性能指标对比
    """
    print("\n" + "=" * 80)
    print("性能对比")
    print("=" * 80)
    
    perf = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                        COCO 数据集性能对比                                   │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┬──────────┬──────────┬──────────┬──────────┬────────────────┐
│  模型    │ 参数量   │  GFLOPs  │ mAP50-95 │  mAP50   │  推理速度      │
├──────────┼──────────┼──────────┼──────────┼──────────┼────────────────┤
│ YOLOv2   │  50.7M   │  62.9    │  ~44%    │  ~62%    │  40 FPS (GPU)  │
│          │          │          │          │          │                │
│ YOLOv8n  │   3.2M   │   8.7    │  37.3%   │  52.6%   │  80+ FPS       │
│ YOLOv8s  │  11.2M   │  28.6    │  44.9%   │  61.8%   │  60+ FPS       │
│ YOLOv8m  │  25.9M   │  78.9    │  50.2%   │  67.2%   │  40+ FPS       │
│ YOLOv8l  │  43.7M   │ 165.2    │  52.9%   │  69.8%   │  30+ FPS       │
│ YOLOv8x  │  68.2M   │ 257.8    │  53.9%   │  71.0%   │  25+ FPS       │
└──────────┴──────────┴──────────┴──────────┴──────────┴────────────────┘

注: 推理速度基于 NVIDIA A100 GPU, batch_size=1

关键观察:
1. YOLOv8n (最小版) 参数量仅为 YOLOv2 的 6.3%
2. YOLOv8s 在相近参数量下，mAP 持平或更优
3. YOLOv8x 比 YOLOv2 mAP 提升约 10 个点


┌─────────────────────────────────────────────────────────────────────────────┐
│                        不同目标尺寸的表现                                     │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┬────────────┬────────────┬────────────┐
│  模型    │  小目标    │  中目标    │  大目标    │
│          │  (AP^S)    │  (AP^M)    │  (AP^L)    │
├──────────┼────────────┼────────────┼────────────┤
│ YOLOv2   │   ~19%     │   ~48%     │   ~58%     │
│ YOLOv8m  │   31.6%    │   54.3%    │   69.4%    │
│ YOLOv8x  │   34.3%    │   57.8%    │   72.3%    │
└──────────┴────────────┴────────────┴────────────┘

关键提升:
• 小目标: YOLOv8 显著提升 (约 12-15 个点)
  原因: 80×80 高分辨率特征图
  
• 中目标: 稳定提升 (约 6-10 个点)
  原因: 更好的特征融合 (PAN)
  
• 大目标: 持续提升 (约 11-14 个点)
  原因: 多尺度检测 + 更强的骨干


┌─────────────────────────────────────────────────────────────────────────────┐
│                        速度-精度权衡                                         │
└─────────────────────────────────────────────────────────────────────────────┘

   mAP
   55%│                                        ● YOLOv8x
      │                                   ● YOLOv8l
   50%│                            ● YOLOv8m
      │                     
   45%│     ● YOLOv8s      
      │          ○ YOLOv2                        
   40%│                     
      │ ● YOLOv8n           
   35%│
      │
   30%└────────────────────────────────────────────→ FPS
      0    20   40   60   80   100

结论:
• YOLOv8 提供更好的速度-精度权衡
• 多个版本适应不同应用场景
• 即使最小版本 (n) 也有竞争力


┌─────────────────────────────────────────────────────────────────────────────┐
│                        部署场景推荐                                          │
└─────────────────────────────────────────────────────────────────────────────┘

┌────────────────────┬──────────────┬────────────────────────┐
│      场景          │   推荐模型   │        原因            │
├────────────────────┼──────────────┼────────────────────────┤
│ 移动端/嵌入式      │  YOLOv8n     │ 最小模型，实时推理     │
│ 边缘设备 (Jetson)  │  YOLOv8s     │ 平衡速度和精度         │
│ 实时视频流         │  YOLOv8m     │ GPU 实时处理           │
│ 离线批处理         │  YOLOv8l/x   │ 追求最高精度           │
│ 云端 API 服务      │  YOLOv8m/l   │ 并发处理多请求         │
│ 竞赛/研究          │  YOLOv8x     │ SOTA 性能              │
│ 传统需求 (2017)    │  YOLOv2      │ 简单、资源受限环境     │
└────────────────────┴──────────────┴────────────────────────┘
    """
    
    print(perf)


# ================================
# 5. 训练时间和资源对比
# ================================

def training_resources_comparison():
    """
    训练资源对比
    """
    print("\n" + "=" * 80)
    print("训练资源对比")
    print("=" * 80)
    
    resources = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                        训练配置对比 (COCO 数据集)                            │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┬────────────┬───────────┬────────────┬──────────────────┐
│  模型    │  GPU 显存  │  批大小   │  训练时间  │  推荐 GPU        │
├──────────┼────────────┼───────────┼────────────┼──────────────────┤
│ YOLOv2   │   6-8 GB   │  64       │  ~3-4 天   │ GTX 1080 Ti      │
│          │            │           │  (300轮)   │                  │
│          │            │           │            │                  │
│ YOLOv8n  │   4-6 GB   │  128      │  ~1-2 天   │ RTX 3060         │
│ YOLOv8s  │   6-8 GB   │  64       │  ~2-3 天   │ RTX 3070         │
│ YOLOv8m  │  10-12 GB  │  32       │  ~3-4 天   │ RTX 3080         │
│ YOLOv8l  │  14-16 GB  │  16       │  ~4-5 天   │ RTX 3090/A100    │
│ YOLOv8x  │  20-24 GB  │  8        │  ~5-7 天   │ A100 (40GB)      │
└──────────┴────────────┴───────────┴────────────┴──────────────────┘

注: 训练时间基于单 GPU，实际时间取决于硬件和数据集


┌─────────────────────────────────────────────────────────────────────────────┐
│                        数据增强对比                                          │
└─────────────────────────────────────────────────────────────────────────────┘

YOLOv2:
├─ 多尺度训练 (320-608)
├─ 随机裁剪
├─ 颜色抖动
├─ 随机翻转
└─ HSV 调整

YOLOv8:
├─ Mosaic (马赛克增强) ⭐
│  • 4 张图拼接
│  • 丰富场景多样性
│  
├─ MixUp ⭐
│  • 图像混合
│  • 提升泛化
│  
├─ Copy-Paste
├─ 随机透视变换
├─ HSV 增强 (改进版)
├─ 随机翻转
├─ 多尺度训练
└─ Albumentations 集成

提升效果:
• Mosaic: +2-3% mAP
• MixUp: +1-2% mAP
• 组合使用: +4-5% mAP


┌─────────────────────────────────────────────────────────────────────────────┐
│                        训练技巧对比                                          │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────────────┬─────────────────────┬────────────────────────┐
│      技巧        │      YOLOv2         │        YOLOv8          │
├──────────────────┼─────────────────────┼────────────────────────┤
│ 预训练策略       │ ImageNet 224→448    │ ImageNet 预训练        │
│ 学习率策略       │ Step decay          │ Cosine annealing ⭐    │
│ 优化器           │ SGD + Momentum      │ SGD / Adam / AdamW     │
│ 正则化           │ Dropout + L2        │ Weight decay           │
│ 归一化           │ Batch Norm          │ Batch Norm             │
│ 激活函数         │ Leaky ReLU          │ SiLU (Swish) ⭐        │
│ 标签分配         │ IoU matching        │ TAL (任务对齐) ⭐       │
│ 早停             │ 手动                │ 自动 (patience) ⭐      │
│ 混合精度         │ 不支持              │ AMP 支持 ⭐             │
│ EMA              │ 不使用              │ 使用 (稳定训练) ⭐      │
└──────────────────┴─────────────────────┴────────────────────────┘

⭐ = 重要改进


┌─────────────────────────────────────────────────────────────────────────────┐
│                        易用性对比                                            │
└─────────────────────────────────────────────────────────────────────────────┘

YOLOv2:
• 配置复杂 (需要修改 .cfg 文件)
• 编译 Darknet (C 代码)
• 命令行工具
• 有限的文档
• 社区支持减少

示例:
$ ./darknet detector train cfg/coco.data cfg/yolov2.cfg darknet19_448.conv.23

YOLOv8:
• 零配置开箱即用 ⭐
• Python API (pip install)
• 丰富的文档和教程
• 活跃的社区
• 集成 Weights & Biases

示例:
from ultralytics import YOLO
model = YOLO('yolov8n.pt')
model.train(data='coco.yaml', epochs=100)

结论:
YOLOv8 显著降低了使用门槛，更适合快速原型开发和生产部署
    """
    
    print(resources)


# ================================
# 主函数
# ================================

if __name__ == "__main__":
    print("\n🔍 YOLOv2 vs YOLOv8 全面对比分析\n")
    
    architecture_comparison()
    prediction_flow_comparison()
    loss_function_comparison()
    performance_comparison()
    training_resources_comparison()
    
    print("\n" + "=" * 80)
    print("总结")
    print("=" * 80)
    
    summary = """
┌─────────────────────────────────────────────────────────────────────────────┐
│                        为什么 YOLOv8 更优秀？                                │
└─────────────────────────────────────────────────────────────────────────────┘

1. 架构创新 ⭐⭐⭐⭐⭐
   • C2f 模块 → 更丰富的梯度流
   • PAN → 更好的特征融合
   • 解耦头 → 任务专用优化
   • Anchor-Free → 简化设计

2. 性能提升 ⭐⭐⭐⭐⭐
   • mAP 提升 ~10 个点
   • 小目标检测显著改善
   • 更快的推理速度
   • 多尺度检测能力

3. 训练优化 ⭐⭐⭐⭐⭐
   • 现代损失函数 (CIoU + DFL)
   • 强大的数据增强 (Mosaic + MixUp)
   • 智能标签分配 (TAL)
   • 混合精度训练支持

4. 易用性 ⭐⭐⭐⭐⭐
   • 一行代码训练
   • 丰富的预训练模型
   • 完善的文档
   • 活跃的社区

5. 部署友好 ⭐⭐⭐⭐⭐
   • 多种导出格式 (ONNX, TensorRT, CoreML...)
   • 移动端优化
   • 量化支持
   • 边缘设备部署

┌─────────────────────────────────────────────────────────────────────────────┐
│                        学习路径建议                                          │
└─────────────────────────────────────────────────────────────────────────────┘

如果你是初学者:
  → 直接学习 YOLOv8
  → 理解基础概念后，回顾 YOLOv2 了解演进

如果你想深入理解:
  → YOLOv1 (基础思想)
  → YOLOv2 (anchor 机制)
  → YOLOv3 (多尺度)
  → YOLOv5-v8 (现代技术)

如果你要做项目:
  → 使用 YOLOv8 (除非有特殊限制)
  → 从预训练模型开始
  → 在自己的数据集上微调

如果你要写论文:
  → 以 YOLOv8 为 baseline
  → 了解最新的改进方向
  → 关注 anchor-free、transformer 等趋势
    """
    
    print(summary)
    
    print("\n" + "=" * 80)
    print("对比演示完成！")
    print("=" * 80)
    print("\n下一步:")
    print("1. 运行 yolov2_implementation.py - 理解 YOLOv2 核心概念")
    print("2. 运行 yolov8_example.py - 学习 YOLOv8 使用")
    print("3. 阅读 training_guide.md - 开始实践训练")
    print("4. 访问 https://docs.ultralytics.com - 查看官方文档")

